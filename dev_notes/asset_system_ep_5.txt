my idea with the asset systems was that - for week 6 for example -
if you did load_frames("characters/BOYFRIEND.xml") it would instead load pixel bf as the week 6
scene starts out and ends with a add/pop_asset_system call.
quite silly considering that pixel bf is kind of separate. i mean, if i take that idea too far,
i might as well have each level be its own entry in there.
practically, such a replacement system is kinda unwieldy for anything past tilemap substitutions.

Let's make some more changes yet again:

def load_sound_plain(path: str, streaming: bool = False, decoder: t.Optional["MediaDecoder"] = None):
	...

^ This is superior to having to import and construct silly SoundResourceOptions

register_asset_type("sound", load_sound_plain)
=> load_sound(path: str, streaming: bool = False, decoder: ..., cache: bool = False) -> Source
(Streamed sources should probably never be cached?)

cache key is (path, streaming, decoder); how to get that?
how do routers supply replacement options now? A good ol' dict may be the solution as usual.
Probably needs some inspect trickery to accumulate ("asdf", True) {decoder=XYZDec} into
{path: "asdf", streaming: True, decoder}
^ Resolved to a horrid mush of kwargs dict which destroys typing, so now the functions have to be
  manually typed. That's fine though, not a lot of them.

=== simple asset: built from a function that gets an absolute path, options and returns an asset by
================= opening the file and processing its contents.
load(full_path, *optionsa, **optionskw) -> T
make_cache_key(path_frag, *optionsa, **optionskw) -> Hashable
gen_loader(path_frag, *optionsa, cache = False, **optionskw) -> T

gen_loader = register_asset("_name", load, make_cache_key)

# make_cache_key could be autogenerated, but that's too much effort. we now need to duplicate
# the options into this signature.

=== complex asset: when given anything, construct something else by loading multiple other assets
================== effectively just an excuse to use the asset system manager's cache.

load(*optionsa, **optionskw) -> T
make_cache_key(*optionsa, **optionskw) -> Hashable
gen_loader(*optionsa, cache = False, **optionskw) -> T

gen_loader = register_complex_asset("_cpxname", load, make_cache_key)

normal/complex assets are relatively similar, a normal asset just has its load method's inputs
augmented by a call to process_asset. for a complex asset, that's route_complex_asset.
i'd say there's a way to merge the two, but the joke for normal assets is that route_asset turns
the path absolute, for complex ones this is not the case.

^ Keeping them split, otherwise a variable like "make_absolute" would need to be passed through
  to route_asset, which complicates that and each AssetRouter's implementation.
  Did however merge the types of AssetRouters together into one.

How to invalidate the cache?
Generally, we want to not run out of memory (Okay, never happened so far outside of a limited VM).
For that, unloading* graphics that (a) are not in use and (b) have not been in use longest is
necessary. Problem is: while b is easy to handle, a is not. Of course abusing the refcount would
be possible but i do not like that; relying on stuff like that locks us in into cpython quickly.
We probably already are due to my genius C-extensions.
*Does "unload" mean "delete" or "remove from cache"? This is irrelevant for non-textures, as those
can not be deleted, but deleted textures still in use will cause terrible bugs/errors.
Textures are not stored in RAM, but VRAM. Should be differentiating between those two. (Does it
make sense to abstract to n storage spaces? Probably not.)

subdivide options into options for the asset system and the actual loader?
atlas_hint is irrelevant to the image loader.
^ Nah, keeping it as is.

For the image loader, tear its atlas store out of the asm and make a special cache subclass for it.

expand the cache to more than a dict (although it should remain a dict for everything that is not
an image). The way the image atlases are jammed into the manager really sucks right now.

When to unload?
 - In response to OOM
 - Unconditionally in loading screens*
 - Unconditionally when scene stack is emptied*
 * Only when memory usage (need to divide between VRAM and RAM?) is hitting a limit (configurable?)
   (How do you get the VRAM limit?)

It would of course be cool to always keep assets such as the alphabet and main menu background.
Main problem child really are characters boasting spritesheets of 8192**2 etc. Maybe a limit of 1GB
of acceptable VRAM usage before some kind of hybrid of unused/largest is deleted.

We could create a doomqueue of assets that are unused. The more loading screens pass, the closer
assets move to its head. Whenever the memory limit is exceeded, the doomqueue is emptied until it
either runs dry or the memory limit is understepped again. When an asset is loaded/used again, it
of gets removed from the doomqueue/pushed to its end again.
For this, the AssetSystemManager needs to be aware of everything cached. For this, make
AssetProviders capable of caching things, but only secondarily. The AssetSystemManager will always
keep a basic dict cache.

Image cache:
 measure (allocated, used) from texture atlases/bins. Possibly copy-paste from pyglet.
Snd cache:
 measure (allocated, used=allocated) from StaticSources.
 Do not cache streaming sources.
bytes:
 measure (allocated, used=allocated) from bytes objects via sys.getsizeof
json:
 measure (allocated, used=allocated) from dicts via recursive sys.getsizeof
 Note that modifications of dicts should not be respected since that's the user's fault.

assume consistency. as long as the asset router stack is never changed, load_xyz(asdf, ghjk)
should always return the same thing.

Threaded loading:
 Assets should be loadable on other threads to not drop frames on the main thread.
 Some assets have to be partially created on the the main thread (Texture creation)
 An asset is loaded once it's in the cache.
1. fetch from disk
2. process into final form (Provider.load)
   |- loadstep 0
   |- loadstep ...
   '- loadstep n
3. router-defined post-load-processors*
   |- plp 0
   |- plp ...
   '- plp n
4. pass to AssetSystemManager cache to encache

Sometimes processing steps must happen on the main thread.
Signal this information when registering an asset provider.
*We may want to have cache-aware providers ignore/prohibit post-load-processors as they may
screw with the provider's cache, which they already fill in their loadsteps.
A loadstep may require to be run on the main thread. Standard AssetProviders only have one
loadstep, their `load` function. Might want to introduce the possibility of more.

bytes:   load from disk -> bytes. done.
most:    load from disk -> transform. done.
image:   load from disk -> decode -> upload to texture[main]. done.
shader:  load from disk -> bytes -> start compile[main] -> wait for compilation to finish (COMPLETION_STATUS_ARB?)

Loading scheme of xml:
def load(path): # Easy enough, may happen on any thread
	with open(path, "r") as f:
		return ElementTree.parse(f)

Loading scheme of image:
def loadstep_0(path, atlas_hint): # Any thread
	image_data = load_image(path, cache=False)
	pyglet.clock.schedule_once(self.loadstep_1, (image_data, atlas_hint))

def loadstep_1(image_data, atlas_hint): # Requires main thread
	...
	image = image_data.get_texture()
	...
	return image

How to signal completion? As far as the ThreadPoolExecutor is concerned, future is done once
loadstep_0 completes. Possibly:

def loadstep_0(path, atlas_hint):
	image_data = load_image(path, cache=False)

	event = threading.Event()
	pyglet.clock.schedule_once(self.loadstep_1, (event, image_data, atlas_hint))
	event.wait()
	event.clear()

def loadstep_1(event, image_data, atlas_hint):
	...
	image = image_data.get_texture()
	...
	event.set()
	return image

^ With a constraint on the forwarded parameters, this function can be created through a decorator.

Calling into other loading functions from threads may be detrimental. Let's go through this...
- Converting path to string is more or less just a string manipulation exercise, should be safe
- Building a cache key is just mashing stuff into a tuple, should be safe
- Resolving the router stack is going to require all has_asset and has_complex_asset functions
  to be thread-safe. To my knowledge they probably are, but we will need to place locks around
  places where the router stack is modified.
- loading the asset is a type-dependant mix of safe and not safe. We need some way to communicate
  loadsteps that are okay and ones that aren't.
- Applying the post-load processors is tricky since it's just random user-defined functions.
  They should probably not do too much though and for most cases of small hacks on the loaded
  assets be safe to call in any thread.
  Facilities to have them guarantee be called in the main thread would make stuff even more
  complicated, ignoring that.
- Encaching should be done with care. Since that involves actually modifying shared structures,
  should probably have a lock guarding it, in addition to the asset router stack lock.

So, since load functions MIGHT call other load functions, those locks should probably be RLocks.
Don't like using them since they're that bit more expensive but whatever, this is python

Assets might refer to other assets. This needs to be considered, so now i have to go build a
reference overseer in there. We can probably track this per loader thread thanks to
`threading.local`. load_a -> load_b -> load_a will cause an infinite loop, good thing we don't have
assets that look like that. You could probably make a logical argument this isn't really a scheme
they'd be ever structured after anyways, so error out whenever we detect this early before having
python blow up with a RecursionError.
Need to count how many times a given asset refers to another one, we can simply do that by checking
the referee's count before and after the load. Seriously locking this into refcounts.

Asset manifests
Flixel asset manifests map to an asset library called "default" by default.
They are defined by an xml tag going <assets path="xxx" />, where the path allows for some
flexibility via a directory which is walked, or including/excluding individual assets.
Additional libraries may be defined via the <library /> tag, which also declares preloadability.
A preloaded library appears have its contents loaded all at once before the FlxGame is created.
It looks like in order to be able load an asset, the library must be loaded.
It is pretty apparent though that not all the assets are immediately uncompressed into memory,
evidenced by low resource usage and a hang when cycling through the freeplay menu, as well as a
significant wait on black screen after the loading screen disappars. Loading an asset library
merely seems to make the asset known to lime.

How to adapt this?
Since i want this thing to be supermoddable and modular in the fuuuuutuuuuuure, i think binding
ourselves to libraries as a "load-all or load-none" is a poor idea. Of course, specifying each and
every asset for every scene is also far from ideal.
Baking an asset router:
 made-up term for walking directories and throwing their files into a dict on some kind of
 router-level. This way, has_asset could operate on a whitelist, not requiring filesystem
 interaction and be a dict lookup. This is definitely faster, can't hang and also will allow us to
 somewhat emulate libraries maybe?
^ Put on hold, libraries should probably be preferred for this now

Let's think back to a usability point. Regular fnf has these week1..7 libraries, which a loading
screen loads if it isn't already and if things aren't being preloaded (otherwise
the loading screen never shows up). Additionally, it has a "songs" and "shared" library, which is
always being loaded in loading screens since you'll need it for music/characters from shared.
I think, ideally loading hints should be generated from an InGameScene, augmentable/definable by
SceneKernels. When loading a week 2 song, it could include a load demand for a library "week2",
which would need to be created by the BaseGameAssetRouter somehow. This would then issue an
encaching call for each required asset, where the BaseGameAssetRouter could have copypasted the
week2 manifest.

Remember, i'm trying to build a system that may allow i.e. the basegame to run with the file
structure used by the ballfart engine or whatever simply by adding an appropiate asset router on
top. So, we'd need to make AssetRouters capable of modifying scan requests for any given library.
Basically: The scan requests (glob patterns btw) of a library go through the router stack, which
then do an exercise in path mangling and guessing, and then end up returning hints that either
correspond to directory scans of the original paths or faked and then de-faked scans. In any case,
the returned loading hints must mirror the original game's paths.

[week3/images/*.png] [BaseGameRouter]
	-> BaseGameRouter
	-{dirscan}-> ["...week3/images/street.png", ...]
	-{eliminate prefix}-> ["week3/images/street.png", ...]
	-{guess types, turn into loading hints}-> {"image": [(("week3/images/street.png",), {}), ...]}

[week3/images/*.png] [XYZRouter, BaseGameRouter]
	-> XYZRouter
	-{transform request}-> [weeks/pico/*.png]
	-{dirscan}-> ["...weeks/pico/street.png", ...]
	-{eliminate prefix}-> ["weeks/pico/street.png", ...]
	-{detransform}-> ["week3/images/street.png", ...]
	-{guess types, turn into loading hints}-> {"image": [(("week3/images/street.png",), {}), ...]}

Registries:
	ContentPack exports stuff into registries (Character, Week)
	A ContentPack might add AssetRouters.
	AssetRouters should be addable independently of content packs as well.
	A ContentPack may in the future take control of the game, dividing them into full and enhancing
	ones.
	So how on earth do the libraries fit in there now?
	an enhancing content pack may declare new ones or use existing ones; but shouldn't expect to
	be able to redeclare "shared".
	A driving content pack should basically be able to do whatever; it's not bound to the base game
	Might still make sense if it was able to use its characters/weeks though?

	I wrote this to consider whether libraries may fit in as a registry. Verdict is: No, they don't.
	They are influenced by individual AssetRouters. I will make them a part of the
	AssetSystemManager and add some kind of build_libraries() function with the purpose of building
	the libraries for a given router stack.
	Remember that at the end of the day, a library is just a wild asset-type-name-to-tuple-of-
	*args-and-**kwargs-map.

L_true_shared_assets:
	assets/shared/images/(bad|combo|go|good|healthBar|ready|set|go).png

tutorial:
	L_true_shared_assets
	assets/shared/images/stageback.png
	assets/shared/images/stagecurtains.png
	assets/shared/images/stagefront.png
	assets/shared/images/characters/GF_assets.xml*
	assets/shared/images/characters/BOYFRIEND.xml*
	assets/songs/tutorial/Inst.ogg
		There is no Voice track. This cannot be communicated to the loading screen cleanly,
		we either have to (a) hardcode the fact there is none into the scene subclass, creating
		a data duplication there and in the song's json file, or (b) take the L and just load the
		instrumental during scene creation, creating realistically like 200ms of waiting time.
		I think i'll go with option b for now, before - knowing me - adding in some completely
		charcoal-brained system for jamming additional assets into a running loading process once
		certain others are loaded (which is then gonna duplicate code checking for the vocal track)
		^
		Yeah, it's decided. The loading screen is gonna be a half-placebo, only very clearly
		defined assets get loaded in it. That's fine, considering it's technically optional all
		along, just looks snazzier.
		^ lol nvm charcoalbrain wins AGAIN YOU FUCKING IDIOT HAHHh

// Assuming someone's playing a week's song, be that through freeplay or story menu, is it likely
// they'll play the other songs soon after? Load assets that may not be present in a given song?
any week 1 song:
	L_true_shared_assets
	assets/shared/images/stageback.png
	assets/shared/images/stagecurtains.png
	assets/shared/images/stagefront.png
	assets/shared/images/characters/DADDY_DEAREST.xml*
	assets/shared/images/characters/GF_assets.xml*
	assets/shared/images/characters/BOYFRIEND.xml*
	.../Inst.ogg
	.../Voices.ogg

any week 2 song:
	L_true_shared_assets
	assets/week2/images/halloween_bg.xml
	assets/shared/images/characters/spooky_kids_assets.xml*
	assets/shared/images/characters/Monster_Assets.xml*
	assets/shared/images/characters/GF_assets.xml*
	assets/shared/images/characters/BOYFRIEND.xml*

*Characters include an offsets file, should ideally be added as well.

[put onto backburner] It would be cool if asset routers could communicate the following via
has_asset:
	FOUND
	 |-NEW_OPTIONS: ?{str: Any}
	 |-FOLLOW_UP_ACTION: Enum{CONTINUE_RESOLVING, TERMINATE, CONCAT}
	 '-PLP: ?(T -> T)
	NOT_FOUND
	// Return type of has_asset: ?(str, Enum{...}, ?{str: Any}, PLP)
The idea is for example enhancing the intro texts by simply adding onto them.
For this, we'd need a concatter (lambda asset0, asset1: asset0 + asset1) and then load the asset
twice, once ignoring the router that emitted the concat command.
This might raise hell with cache-aware assets, possibly limit there.
We could take this even further (or actually, just change the point of view) to replace the load
method entirely. Think of getting embedded assets like funkscop's Impatience, reading them from
a database, or straight-up downloading them from somewhere.
Currently (v0.0.51), the system is at its foundation pretty convinced that an asset is made out
of base components that at the end of the day are just one file each.
