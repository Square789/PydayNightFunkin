from pathlib import Path

from opengl_registry import RegistryReader

from ._common import cwd_sanity_check, get_options

GL_XML_PATH, = get_options(("gl-xml-path", str, None))


# OpenGL function addresses must be resolved at runtime. Usually, something like GLAD does this.
# Luckily, we are able to piggyback off of pyglet's loading routines to get all these sweet
# function pointers down to cython.
# This script autogenerates a cython module whose main purpose is doing that. Pass it pyglet's
# gl module and it will populate a C struct that serves as the central registry.
# Other cython modules that want to interact with OpenGL can then cimport `cygl_get_reg` and use
# that registry.


PXD_TEMPLATE = """
#                            NOTICE                   #
# This file was autogenerated by `codegen/gl_gen.py`. #
# Do not modify it! (Or do, i'm not your dad.)        #
# For permanent changes though, modify `gl_gen.py`.   #

from libc.stdint cimport *


ctypedef unsigned int GLenum
ctypedef unsigned char GLboolean
ctypedef void GLvoid
ctypedef int GLint
ctypedef unsigned int GLuint
ctypedef int GLsizei
ctypedef unsigned long int GLsizeiptr
ctypedef long int GLintptr
ctypedef double GLdouble
ctypedef char GLchar
ctypedef unsigned int GLbitfield

{funcptr_defs}

cdef extern from *:
	\"\"\"
{gl_constant_c_defines}	\"\"\"
{gl_constant_cython_extern_defs}

ctypedef struct GLRegistry:
{gl_registry_struct_def}

cdef GLRegistry *cygl_get_reg() except NULL
cdef uint8_t cygl_errcheck() except 1
cdef size_t cygl_get_gl_type_size(GLenum type_)
"""


PYX_TEMPLATE = """
#                            NOTICE                             #
# This file was autogenerated by `gl_gen.py`. Do not modify it! #
# (Or do, i'm not your dad.)                                    #
# For permanent changes though, modify the generator script.    #

import ctypes
from pyday_night_funkin.core.graphics.cygl cimport gl

cdef bint _is_initialized = False

cdef gl.GLRegistry _gl_reg

ctypedef void (* SetGLFunc_f)(uintptr_t addressof)

# Completely unsafe hacks that make function addresses available to cython.
# I love and hate C for this.
# https://stackoverflow.com/questions/49635105/ctypes-get-the-actual-address-of-a-c-function

{initializer_funcs}

class OpenGLError(Exception):
	pass


cdef GLRegistry *cygl_get_reg() except NULL:
	if not _is_initialized:
		raise RuntimeError("cygl was not initialized!")
	return &_gl_reg

cdef uint8_t cygl_errcheck() except 1:
	if not _is_initialized:
		raise RuntimeError("cygl was not initialized!")

	cdef GLenum err = _gl_reg.GetError()
	if err == 0:
		return 0

	cdef str err_str = "Unkown error code. Something is seriously off."
	if err == GL_INVALID_ENUM:
		err_str = "Invalid enum value (Oooh what could the cause for this one be?)"
	elif err == GL_INVALID_VALUE:
		err_str = "Invalid value (Most descriptive OpenGL error)"
	elif err == GL_INVALID_OPERATION:
		err_str = "Invalid operation (Happy guessing!)"
	elif err == GL_INVALID_FRAMEBUFFER_OPERATION:
		err_str = "Invalid Framebuffer operation"
	elif err == GL_OUT_OF_MEMORY:
		err_str = "Out of memory"
	raise OpenGLError(err_str)

#########################################################################################
# ! Check the entire codebase for "PNF_OPEN_GL_TYPE_DEFINITIONS" when modifiying this ! #
#########################################################################################
cdef size_t cygl_get_gl_type_size(GLenum type_):
	if type_ in (GL_BYTE, GL_UNSIGNED_BYTE):
		return 1
	elif type_ in (GL_SHORT, GL_UNSIGNED_SHORT):
		return 2
	elif type_ in (GL_INT, GL_UNSIGNED_INT, GL_FLOAT):
		return 4
	elif type_ in (GL_DOUBLE,):
		return 8
	else:
		return 0


NAME_TO_INITIALIZER_DICT = {name_to_initializer_dict}

def initialize(module):
	global _is_initialized
	if _is_initialized:
		return

	cdef set uninitialized = set(NAME_TO_INITIALIZER_DICT)
	cdef uintptr_t address
	for name in NAME_TO_INITIALIZER_DICT:
		address = 0
		try:
			thing = getattr(module, name)
		except AttributeError:
			raise RuntimeError(
				f"GL module did not possess required attribute {{name!r}}"
			) from None

		if hasattr(thing, "func") and thing.func is None:
			# HACK Not gonna run an isinstance check here
			# This is likely a WGLFunctionProxy.
			# This branch should only run if we are on windows, so importing wglGetProcAddress
			# shooooould succeed.
			# It furthermore shooooould be returning function pointers.
			# Do not bother resolving the proxy, it can go do that on its own.
			# We just need to get the function address.

			from pyglet.gl.lib_wgl import wglGetProcAddress
			name_buf = ctypes.create_string_buffer(thing.name.encode("utf-8"))
			address = <uintptr_t>ctypes.addressof(wglGetProcAddress(name_buf))
			del name_buf
			if address == 0:
				raise RuntimeError(f"wglGetProcAddress returned NULL; {{name!r}} unavailable")
		else:
			address_haver = thing
			if hasattr(thing, "func"):
				# Likely a WGLFunction (formerly WGLFunctionProxy but with its __class__ attribute
				# replaced like wtf); its func should already be setup and good to go by giving it
				# to addressof.
				address_haver = thing.func

			try:
				address = <uintptr_t>ctypes.addressof(address_haver)
			except TypeError:
				raise TypeError(
					f"ctypes.addressof raised TypeError when trying to register {{name!r}}, "
					f"type was {{address_haver.__class__.__name__!r}}"
				) from None

		NAME_TO_INITIALIZER_DICT[name](address)
		uninitialized.remove(name)

	if uninitialized:
		raise RuntimeError(
			f"The cython GL registry was not fully initialized."
			f"First missing value: {{next(iter(uninitialized))!r}}"
		)

	_is_initialized = True
"""


DEFINED_TYPES = {
	"GLenum", "GLboolean", "GLvoid", "GLint", "GLuint", "GLsizei",
	"GLsizeiptr", "GLintptr", "GLdouble", "GLchar", "GLbitfield"
}

REQUIRED_ENUMS = {
	"GL_DYNAMIC_READ",
	"GL_READ_ONLY",
	"GL_MAP_READ_BIT",
	"GL_MAP_WRITE_BIT",

	"GL_INVALID_ENUM",
	"GL_INVALID_VALUE",
	"GL_INVALID_OPERATION",
	"GL_INVALID_FRAMEBUFFER_OPERATION",
	"GL_OUT_OF_MEMORY",

	# ! These should always be the same set of   ! #
	# ! type names found in core.graphics.shared ! #
	# !        PNF_OPEN_GL_TYPE_DEFINITIONS      ! #
	"GL_BYTE",
	"GL_UNSIGNED_BYTE",
	"GL_SHORT",
	"GL_UNSIGNED_SHORT",
	"GL_INT",
	"GL_UNSIGNED_INT",
	"GL_FLOAT",
	"GL_DOUBLE",
}

REQUIRED_COMMANDS = {
	"glGetError": "GetError",

	# Buffer stuff
	"glCreateBuffers": "CreateBuffers",
	"glDeleteBuffers": "DeleteBuffers",

	"glBufferData": "BufferData",
	"glNamedBufferData": "NamedBufferData",
	"glBufferSubData": "BufferSubData",
	"glNamedBufferSubData": "NamedBufferSubData",

	"glMapNamedBuffer": "MapNamedBuffer",
	"glMapNamedBufferRange": "MapNamedBufferRange",
	"glUnmapNamedBuffer": "UnmapNamedBuffer",

	"glBindBuffer": "BindBuffer",
}

def _make_funcptr_name(name: str) -> str:
	return "FPTR_" + name


def main():
	cwd_sanity_check("codegen/gl_gen.py")

	gl_reg_struct_members = ""

	if GL_XML_PATH is None:
		rr = RegistryReader.from_url()
	else:
		rr = RegistryReader.from_file(GL_XML_PATH)

	enum_defines = ""
	enum_cython_externs = ""
	funcptr_defs = ""
	# Add needed enums
	for enum in rr.read_enums().values():
		if enum.name in REQUIRED_ENUMS:
			enum_defines += f"\t#define {enum.name} {enum.value}\n"
			enum_cython_externs += f"\tconst GLenum {enum.name}\n"

	# Add needed command declarations
	for name, cmd in rr.read_commands().items():
		if name not in REQUIRED_COMMANDS:
			continue

		args = []
		for prm in cmd.params:
			if "void" in prm.value:
				args.append("const void *" + prm.name)
			elif prm.ptype is None:
				raise ValueError(f"Missing param type for {prm.name} of {cmd.name}.")
				return 1
			else:
				if prm.ptype not in DEFINED_TYPES:
					raise ValueError(f"Type {prm.ptype!r} is not defined")
					return 1
				args.append(prm.value)

		if cmd.ptype is None:
			rtype = "void " + ('*' * cmd.proto.count('*'))
		else:
			if cmd.ptype not in DEFINED_TYPES:
				raise ValueError(f"type {cmd.ptype!r} is not defined")
			rtype = cmd.ptype + ' '

		translated_name = REQUIRED_COMMANDS[name]
		fptr_name = _make_funcptr_name(translated_name)
		funcptr_defs += f"ctypedef {rtype}(* {fptr_name})({', '.join(args)})\n"
		gl_reg_struct_members += f"\t{fptr_name} {translated_name}\n"


	name_to_initializer_dict = "{\n"
	initializer_funcs = ""
	for orig_name, cy_name in REQUIRED_COMMANDS.items():
		fptr_name = _make_funcptr_name(cy_name)
		regfunc_name = f"_register_{orig_name}"
		initializer_funcs += f"cdef void {regfunc_name}(uintptr_t func_ptr):\n"
		initializer_funcs += f"\t_gl_reg.{cy_name} = (<{fptr_name} *>func_ptr)[0]\n\n"
		name_to_initializer_dict += f"\t\"{orig_name}\": {regfunc_name},\n"

	name_to_initializer_dict += "}\n"

	cygl_dir = Path.cwd() / "pyday_night_funkin/core/graphics/cygl"
	with (cygl_dir / "gl.pxd").open("w", encoding="utf-8") as f:
		f.write(PXD_TEMPLATE.format(
			funcptr_defs = funcptr_defs,
			gl_constant_c_defines = enum_defines,
			gl_constant_cython_extern_defs = enum_cython_externs,
			gl_registry_struct_def = gl_reg_struct_members,
		))

	with (cygl_dir / "gl.pyx").open("w", encoding="utf-8") as f:
		f.write(PYX_TEMPLATE.format(
			initializer_funcs = initializer_funcs,
			name_to_initializer_dict = name_to_initializer_dict,
		))

	return 0


if __name__ == "__main__":
	main()
