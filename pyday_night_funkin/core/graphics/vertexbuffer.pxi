
#                           NOTICE                              #
# This file was autogenerated by `codegen/vertexbuffer_gen.py`. #
# Do not modify it! (Or do, i'm not your dad.)                  #
# For permanent changes though, modify the generator script.    #

ctypedef uint8_t (* FPTR_pyobj_extractor)(size_t size, void *target, object data_collection) except 1

cdef uint8_t extract_bytes(size_t size, void *target, object data_collection) except 1:
	cdef int8_t *cast_target = <int8_t *>target
	cdef size_t i = 0
	for i, it in enumerate(data_collection):
		if not isinstance(it, int):
			raise TypeError(f"Bad python type {type(it)!r} for supplied buffer data.")
		if i >= size:
			break

		cast_target[i] = <int8_t>it
	return 0

cdef uint8_t extract_unsigned_bytes(size_t size, void *target, object data_collection) except 1:
	cdef uint8_t *cast_target = <uint8_t *>target
	cdef size_t i = 0
	for i, it in enumerate(data_collection):
		if not isinstance(it, int):
			raise TypeError(f"Bad python type {type(it)!r} for supplied buffer data.")
		if i >= size:
			break

		cast_target[i] = <uint8_t>it
	return 0

cdef uint8_t extract_shorts(size_t size, void *target, object data_collection) except 1:
	cdef int16_t *cast_target = <int16_t *>target
	cdef size_t i = 0
	for i, it in enumerate(data_collection):
		if not isinstance(it, int):
			raise TypeError(f"Bad python type {type(it)!r} for supplied buffer data.")
		if i >= size:
			break

		cast_target[i] = <int16_t>it
	return 0

cdef uint8_t extract_unsigned_shorts(size_t size, void *target, object data_collection) except 1:
	cdef uint16_t *cast_target = <uint16_t *>target
	cdef size_t i = 0
	for i, it in enumerate(data_collection):
		if not isinstance(it, int):
			raise TypeError(f"Bad python type {type(it)!r} for supplied buffer data.")
		if i >= size:
			break

		cast_target[i] = <uint16_t>it
	return 0

cdef uint8_t extract_ints(size_t size, void *target, object data_collection) except 1:
	cdef int32_t *cast_target = <int32_t *>target
	cdef size_t i = 0
	for i, it in enumerate(data_collection):
		if not isinstance(it, int):
			raise TypeError(f"Bad python type {type(it)!r} for supplied buffer data.")
		if i >= size:
			break

		cast_target[i] = <int32_t>it
	return 0

cdef uint8_t extract_unsigned_ints(size_t size, void *target, object data_collection) except 1:
	cdef uint32_t *cast_target = <uint32_t *>target
	cdef size_t i = 0
	for i, it in enumerate(data_collection):
		if not isinstance(it, int):
			raise TypeError(f"Bad python type {type(it)!r} for supplied buffer data.")
		if i >= size:
			break

		cast_target[i] = <uint32_t>it
	return 0

cdef uint8_t extract_floats(size_t size, void *target, object data_collection) except 1:
	cdef float *cast_target = <float *>target
	cdef size_t i = 0
	for i, it in enumerate(data_collection):
		if not isinstance(it, (int, float)):
			raise TypeError(f"Bad python type {type(it)!r} for supplied buffer data.")
		if i >= size:
			break

		cast_target[i] = <float>it
	return 0

cdef uint8_t extract_doubles(size_t size, void *target, object data_collection) except 1:
	cdef double *cast_target = <double *>target
	cdef size_t i = 0
	for i, it in enumerate(data_collection):
		if not isinstance(it, (int, float)):
			raise TypeError(f"Bad python type {type(it)!r} for supplied buffer data.")
		if i >= size:
			break

		cast_target[i] = <double>it
	return 0

cdef inline FPTR_pyobj_extractor get_pyobj_extractor_function(GLenum gl_type):
	if gl_type == GL_BYTE:
		return extract_bytes
	elif gl_type == GL_UNSIGNED_BYTE:
		return extract_unsigned_bytes
	elif gl_type == GL_SHORT:
		return extract_shorts
	elif gl_type == GL_UNSIGNED_SHORT:
		return extract_unsigned_shorts
	elif gl_type == GL_INT:
		return extract_ints
	elif gl_type == GL_UNSIGNED_INT:
		return extract_unsigned_ints
	elif gl_type == GL_FLOAT:
		return extract_floats
	elif gl_type == GL_DOUBLE:
		return extract_doubles

	return NULL

@cython.unraisable_tracebacks(True)
cdef inline uint8_t _verify_index_access(size_t buf_size, size_t index) except 1:
	if index >= buf_size:
		raise IndexError(f"Index {index} out of bounds for buffer of size {buf_size}.")
	return 0

@cython.unraisable_tracebacks(True)
cdef inline uint8_t _verify_range_access(size_t buf_size, size_t start, size_t range_size) except 1:
	# Some functions (e.g. memmove) state their arguments must be valid pointers,
	# whether the size of the copied region is 0 is irrelevant.
	# Also, in theory, if such an insanely large start and range size were passed that
	# they overflowed they could cause the start access to fail and the other to succeed.
	_verify_index_access(buf_size, start)
	if range_size > 0:
		_verify_index_access(buf_size, start + range_size - 1)
	return 0

@cython.unraisable_tracebacks(True)
cdef inline uint8_t _verify_is_ctypes_array(object o) except 1:
	if not isinstance(o, ctypes_Array):
		raise TypeError("Object must be a ctypes array!")
	return 0

